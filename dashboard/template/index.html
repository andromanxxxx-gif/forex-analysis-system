<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script>
// Global state untuk menyimpan data chart
let currentChartData = [];
let currentEmaData = [];
let currentMacdData = { macd: [], signal: [], hist: [] };
let lastCandleTime = null;

/* ===== PERBAIKAN: Fungsi untuk memuat data historical ===== */
async function fetchPriceData(pair, timeframe) {
  const tf = getTimeframeFilename(timeframe);
  
  try {
    console.log(`Fetching historical data for ${pair}-${tf}...`);
    const response = await fetch(`/api/historical-data?pair=${pair}&timeframe=${tf}`);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    console.log(`Received ${data.length} data points for ${pair}-${tf}`);
    return data;
  } catch (error) {
    console.error('Error fetching historical data:', error);
    console.log('Using sample data as fallback');
    return generateSamplePriceData(timeframe);
  }
}

// Mapping timeframe ke format yang sesuai dengan backend
function getTimeframeFilename(timeframe) {
  const mapping = {
    '1D': '1D',
    '4H': '4H', 
    '1H': '1H',
    '30m': 'M30'
  };
  return mapping[timeframe] || '1D';
}

// Fungsi untuk menghasilkan data sample
function generateSamplePriceData(timeframe) {
  const data = [];
  const basePrice = 148.75;
  const now = new Date();
  
  let numPoints, volatility, timeIncrement;
  
  switch(timeframe) {
    case '1D':
      numPoints = 100;
      volatility = 2.0;
      timeIncrement = 24 * 60 * 60 * 1000;
      break;
    case '4H':
      numPoints = 150;
      volatility = 0.8;
      timeIncrement = 4 * 60 * 60 * 1000;
      break;
    case '1H':
      numPoints = 168;
      volatility = 0.4;
      timeIncrement = 60 * 60 * 1000;
      break;
    case '30m':
      numPoints = 336;
      volatility = 0.2;
      timeIncrement = 30 * 60 * 1000;
      break;
    default:
      numPoints = 100;
      volatility = 2.0;
      timeIncrement = 24 * 60 * 60 * 1000;
  }
  
  for (let i = numPoints; i >= 0; i--) {
    const date = new Date(now.getTime() - (i * timeIncrement));
    
    const open = basePrice + (Math.random() - 0.5) * volatility;
    const close = open + (Math.random() - 0.5) * volatility * 0.75;
    const high = Math.max(open, close) + Math.random() * volatility * 0.5;
    const low = Math.min(open, close) - Math.random() * volatility * 0.5;
    
    data.push({
      time: date.toISOString().split('T')[0],
      open: parseFloat(open.toFixed(4)),
      high: parseFloat(high.toFixed(4)),
      low: parseFloat(low.toFixed(4)),
      close: parseFloat(close.toFixed(4))
    });
  }
  
  console.log(`Generated ${numPoints} sample data points for timeframe: ${timeframe}`);
  return data;
}

/* ===== PERBAIKAN UTAMA: Utilities dengan error handling yang lebih baik ===== */
function calcEMA(values, period){
  if (!values || values.length === 0) return [];
  const k=2/(period+1);
  let ema=[values[0]];
  for(let i=1;i<values.length;i++) {
    const emaValue = values[i]*k+ema[i-1]*(1-k);
    ema.push(isNaN(emaValue) ? values[i] : emaValue);
  }
  return ema;
}

function calcMACDSeries(c,short=12,long=26,signal=9){
  if (!c || c.length === 0) return {macd: [], sig: [], hist: []};
  const emaS=calcEMA(c,short),emaL=calcEMA(c,long);
  const macd=c.map((_,i)=>(emaS[i]||0)-(emaL[i]||0));
  const sig=calcEMA(macd,signal);
  const hist=macd.map((v,i)=>(v||0)-(sig[i]||0));
  return {macd,sig,hist};
}

// Calculate Pivot Points
function calculatePivotPoints(high, low, close) {
  const pivot = (high + low + close) / 3;
  const r1 = (2 * pivot) - low;
  const s1 = (2 * pivot) - high;
  const r2 = pivot + (high - low);
  const s2 = pivot - (high - low);
  const r3 = high + 2 * (pivot - low);
  const s3 = low - 2 * (high - pivot);
  
  return {
    pivot: pivot,
    r1: r1,
    r2: r2,
    r3: r3,
    s1: s1,
    s2: s2,
    s3: s3
  };
}

/* ===== PERBAIKAN UTAMA: Fungsi cleanChartData yang lebih robust ===== */
function cleanChartData(data) {
  if (!data || !Array.isArray(data)) {
    console.warn('Invalid data provided to cleanChartData:', data);
    return generateSamplePriceData('1D');
  }
  
  return data
    .filter(item => {
      if (!item) return false;
      
      // Pastikan semua field required ada dan valid
      const hasValidTime = item.time && typeof item.time === 'string' && item.time.length > 0;
      const hasValidOpen = item.open !== null && item.open !== undefined && !isNaN(parseFloat(item.open));
      const hasValidHigh = item.high !== null && item.high !== undefined && !isNaN(parseFloat(item.high));
      const hasValidLow = item.low !== null && item.low !== undefined && !isNaN(parseFloat(item.low));
      const hasValidClose = item.close !== null && item.close !== undefined && !isNaN(parseFloat(item.close));
      
      return hasValidTime && hasValidOpen && hasValidHigh && hasValidLow && hasValidClose;
    })
    .map(item => {
      // Normalisasi data dan pastikan tidak ada null/undefined
      const time = String(item.time || '').trim();
      const open = parseFloat(item.open) || 0;
      const high = parseFloat(item.high) || Math.max(open, parseFloat(item.close) || 0);
      const low = parseFloat(item.low) || Math.min(open, parseFloat(item.close) || 0);
      const close = parseFloat(item.close) || open;
      
      // Pastikan high adalah nilai tertinggi dan low adalah nilai terendah
      const adjustedHigh = Math.max(open, high, close);
      const adjustedLow = Math.min(open, low, close);
      
      return {
        time: time || '2023-01-01',
        open: open,
        high: adjustedHigh,
        low: adjustedLow,
        close: close
      };
    })
    .filter(item => {
      // Final validation pass
      return item.time && 
             !isNaN(item.open) && item.open > 0 &&
             !isNaN(item.high) && item.high > 0 &&
             !isNaN(item.low) && item.low > 0 &&
             !isNaN(item.close) && item.close > 0 &&
             item.high >= item.low &&
             item.high >= Math.max(item.open, item.close) &&
             item.low <= Math.min(item.open, item.close);
    });
}

/* ===== PERBAIKAN: Fungsi untuk memvalidasi data sebelum di-set ke chart ===== */
function validateChartData(data) {
  if (!data || !Array.isArray(data)) {
    console.error('Invalid data provided to validateChartData');
    return false;
  }
  
  if (data.length === 0) {
    console.warn('Empty data array provided to validateChartData');
    return false;
  }
  
  // Check first few items untuk memastikan struktur data benar
  const sample = data.slice(0, 5);
  const isValid = sample.every(item => 
    item && 
    typeof item === 'object' &&
    'time' in item &&
    'open' in item &&
    'high' in item &&
    'low' in item &&
    'close' in item
  );
  
  if (!isValid) {
    console.error('Data structure invalid:', sample);
  }
  
  return isValid;
}

/* ===== PERBAIKAN: Safe chart update functions ===== */
function safeSetChartData(chartSeries, data) {
  try {
    if (!validateChartData(data)) {
      console.error('Cannot set invalid data to chart');
      return false;
    }
    
    // Pastikan data tidak terlalu banyak untuk performa
    const limitedData = data.length > 5000 ? data.slice(-5000) : data;
    
    chartSeries.setData(limitedData);
    console.log(`Successfully set ${limitedData.length} data points to chart`);
    return true;
  } catch (error) {
    console.error('Error setting chart data:', error);
    return false;
  }
}

function safeUpdateChartData(chartSeries, dataPoint) {
  try {
    if (!dataPoint || !dataPoint.time) {
      console.error('Invalid data point for update:', dataPoint);
      return false;
    }
    
    chartSeries.update(dataPoint);
    return true;
  } catch (error) {
    console.error('Error updating chart data:', error);
    return false;
  }
}

/* ===== Risk Management Functions ===== */
function updateRiskAssessment(riskData) {
  const riskScore = riskData.risk_score || 0;
  const approved = riskData.approved;
  const rejectionReasons = riskData.rejection_reasons || [];
  const riskFactors = riskData.risk_factors || [];
  
  // Update risk score badge
  const riskScoreBadge = document.getElementById('riskScoreBadge');
  riskScoreBadge.textContent = `Score: ${riskScore}/10`;
  riskScoreBadge.className = `badge ${
    riskScore <= 3 ? 'bg-success' : 
    riskScore <= 6 ? 'bg-warning' : 'bg-danger'
  }`;
  
  // Update risk status display
  const riskMainStatus = document.getElementById('riskMainStatus');
  const riskSubStatus = document.getElementById('riskSubStatus');
  const riskStatus = document.getElementById('riskStatus');
  const riskIcon = riskStatus.querySelector('.risk-icon i');
  
  if (approved) {
    riskMainStatus.textContent = 'APPROVED';
    riskSubStatus.textContent = 'Trade meets risk criteria';
    riskStatus.style.background = 'linear-gradient(135deg, #f0f9ff, #e0f2fe)';
    riskStatus.style.border = '2px solid #bae6fd';
    riskIcon.className = 'fas fa-check-circle fa-2x text-success';
  } else {
    riskMainStatus.textContent = 'REJECTED';
    riskSubStatus.textContent = rejectionReasons.length > 0 ? 
      rejectionReasons[0] : 'Trade does not meet risk criteria';
    riskStatus.style.background = 'linear-gradient(135deg, #fef2f2, #fee2e2)';
    riskStatus.style.border = '2px solid #fecaca';
    riskIcon.className = 'fas fa-times-circle fa-2x text-danger';
  }
  
  // Update risk meter
  const riskMeterFill = document.getElementById('riskMeterFill');
  riskMeterFill.style.width = `${riskScore * 10}%`;
  riskMeterFill.style.background = riskScore <= 3 ? '#10b981' : 
                                  riskScore <= 6 ? '#f59e0b' : '#ef4444';
  
  // Update risk factors
  const riskFactorsContainer = document.getElementById('riskFactors');
  riskFactorsContainer.innerHTML = '';
  
  if (riskFactors.length > 0) {
    riskFactors.forEach(factor => {
      const factorElement = document.createElement('div');
      factorElement.className = 'col-6';
      
      let statusClass = 'pending';
      let statusIcon = 'clock';
      
      if (factor.status === 'low') {
        statusClass = 'low';
        statusIcon = 'check-circle';
      } else if (factor.status === 'medium') {
        statusClass = 'medium';
        statusIcon = 'exclamation-triangle';
      } else if (factor.status === 'high') {
        statusClass = 'high';
        statusIcon = 'times-circle';
      }
      
      factorElement.innerHTML = `
        <div class="risk-factor-card ${statusClass}">
          <i class="fas fa-${statusIcon} me-2"></i>
          <div>
            <div class="risk-factor-name">${factor.name}</div>
            <div class="risk-factor-status">${factor.status.toUpperCase()}</div>
          </div>
        </div>
      `;
      riskFactorsContainer.appendChild(factorElement);
    });
  }
  
  // Update risk details
  const riskDetails = document.getElementById('riskDetails');
  const riskWarnings = document.getElementById('riskWarnings');
  const riskRejections = document.getElementById('riskRejections');
  
  if (rejectionReasons.length > 0) {
    riskDetails.style.display = 'block';
    riskWarnings.style.display = 'none';
    riskRejections.style.display = 'block';
    riskRejections.innerHTML = `<i class="fas fa-times-circle me-2"></i><span>${rejectionReasons.join(', ')}</span>`;
  } else if (riskScore > 6) {
    riskDetails.style.display = 'block';
    riskWarnings.style.display = 'block';
    riskRejections.style.display = 'none';
    riskWarnings.innerHTML = `<i class="fas fa-exclamation-triangle me-2"></i><span>High risk score detected - proceed with caution</span>`;
  } else {
    riskDetails.style.display = 'none';
  }
}

/* ===== Support & Resistance Functions ===== */
function updateSupportResistance(data) {
  const srData = data.support_resistance || {};
  const currentPrice = data.price_data?.current || 0;
  
  // Update Support & Resistance levels
  const supportLevel = srData.support || (currentPrice * 0.995).toFixed(4);
  const resistanceLevel = srData.resistance || (currentPrice * 1.005).toFixed(4);
  
  document.getElementById('supportLevel').textContent = supportLevel;
  document.getElementById('resistanceLevel').textContent = resistanceLevel;
  
  // Calculate and display distances
  if (currentPrice > 0) {
    const supportDistance = ((currentPrice - supportLevel) / currentPrice * 100).toFixed(2);
    const resistanceDistance = ((resistanceLevel - currentPrice) / currentPrice * 100).toFixed(2);
    
    document.getElementById('supportDistance').textContent = `${supportDistance}% below`;
    document.getElementById('resistanceDistance').textContent = `${resistanceDistance}% above`;
  }
  
  // Calculate and update Pivot Points
  const priceSeries = data.price_series || [];
  if (priceSeries.length > 0) {
    const lastDay = priceSeries[priceSeries.length - 1];
    const pivots = calculatePivotPoints(
      parseFloat(lastDay.high) || currentPrice * 1.01,
      parseFloat(lastDay.low) || currentPrice * 0.99,
      parseFloat(lastDay.close) || currentPrice
    );
    
    document.getElementById('pivotPoint').textContent = pivots.pivot.toFixed(4);
    document.getElementById('pivotR1').textContent = pivots.r1.toFixed(4);
    document.getElementById('pivotR2').textContent = pivots.r2.toFixed(4);
    document.getElementById('pivotR3').textContent = pivots.r3.toFixed(4);
    document.getElementById('pivotS1').textContent = pivots.s1.toFixed(4);
    document.getElementById('pivotS2').textContent = pivots.s2.toFixed(4);
    document.getElementById('pivotS3').textContent = pivots.s3.toFixed(4);
  }
}

/* ===== Chart Setup ===== */
let chart, candle, ema26, macdChart, macdLine, macdSignal, macdHist;

// PERBAIKAN: Function untuk initialize charts dengan error handling
function initializeCharts() {
  try {
    // Main chart
    chart = LightweightCharts.createChart(document.getElementById('chartRoot'), {
      layout: { 
        backgroundColor: '#fff', 
        textColor: '#111' 
      },
      grid: {
        vertLines: { color: '#f3f4f6' },
        horzLines: { color: '#f3f4f6' }
      },
      timeScale: {
        borderColor: '#eee',
        timeVisible: true,
        secondsVisible: false
      },
      rightPriceScale: {
        borderColor: '#eee'
      },
      width: document.getElementById('chartRoot').clientWidth,
      height: 520
    });

    candle = chart.addCandlestickSeries({
      upColor: '#16a34a',
      downColor: '#dc2626', 
      borderVisible: true,
      wickUpColor: '#16a34a',
      wickDownColor: '#dc2626'
    });

    ema26 = chart.addLineSeries({
      color: '#2563eb',
      lineWidth: 1.5,
      priceScaleId: 'right'
    });

    // MACD chart
    macdChart = LightweightCharts.createChart(document.getElementById('macdRoot'), {
      layout: { 
        backgroundColor: '#fff', 
        textColor: '#111' 
      },
      grid: {
        vertLines: { color: '#f3f4f6' },
        horzLines: { color: '#f3f4f6' }
      },
      timeScale: {
        borderColor: '#eee',
        timeVisible: true,
        secondsVisible: false
      },
      width: document.getElementById('macdRoot').clientWidth,
      height: 160
    });

    macdLine = macdChart.addLineSeries({
      color: '#0ea5e9',
      lineWidth: 1
    });

    macdSignal = macdChart.addLineSeries({
      color: '#f59e0b', 
      lineWidth: 1
    });

    macdHist = macdChart.addHistogramSeries({
      color: '#a78bfa',
      priceFormat: {
        type: 'volume',
      }
    });

    // Sync time scales between charts
    chart.timeScale().subscribeVisibleTimeRangeChange((timeRange) => {
      try {
        macdChart.timeScale().setVisibleRange(timeRange);
      } catch (e) {
        console.log('Time scale sync error:', e);
      }
    });

    console.log('Charts initialized successfully');
    return true;
  } catch (error) {
    console.error('Error initializing charts:', error);
    return false;
  }
}

/* ===== DOM refs ===== */
const livePriceEl = document.getElementById('livePrice');
const pairSelect = document.getElementById('pairSelect');
const timeframeSelect = document.getElementById('timeframeSelect');
const aiSummaryEl = document.getElementById('aiSummary');
const aiSignal = document.getElementById('aiSignalBadge');
const aiConfidence = document.getElementById('aiConfidence');
const aiRisk = document.getElementById('aiRisk');
const aiEntry = document.getElementById('aiEntry');
const aiSL = document.getElementById('aiSL');
const aiTP1 = document.getElementById('aiTP1');
const aiTP2 = document.getElementById('aiTP2');
const fundNews = document.getElementById('fundamentalNews');
const rsiEl = document.getElementById('rsiVal');
const macdValEl = document.getElementById('macdVal');
const macdHistVal = document.getElementById('macdHistVal');
const adxEl = document.getElementById('adxVal');
const atrEl = document.getElementById('atrVal');
const volEl = document.getElementById('volVal');
const trendEl = document.getElementById('trendVal');
const changeEl = document.getElementById('pairChange');
const statusIndicator = document.getElementById('statusIndicator');
const backtestResultsEl = document.getElementById('backtestResults');
const backtestStatusEl = document.getElementById('backtestStatus');
const currentPriceEl = document.getElementById('currentPrice');

/* ===== Data state ===== */
let auto = false, autoRefreshInterval = null, livePriceInterval = null;
let currentSignal = 'HOLD';

function setSignal(sig){
  aiSignal.textContent = sig;
  currentSignal = sig;
  aiSignal.className = sig === 'BUY' ? 'ai-signal-buy' : 
                     sig === 'SELL' ? 'ai-signal-sell' : 'ai-signal-hold';
}

// Update status indicator
function updateStatusIndicator(isLive) {
  if (isLive) {
    statusIndicator.className = 'status-indicator status-live';
    statusIndicator.title = 'Live data connection active';
  } else {
    statusIndicator.className = 'status-indicator status-offline';
    statusIndicator.title = 'No live data connection';
  }
}

// Generate sample risk assessment data
function generateSampleRiskAssessment() {
  const riskScore = Math.floor(Math.random() * 11); // 0-10
  const approved = riskScore <= 7;
  
  const riskFactors = [
    { name: 'Market Volatility', status: Math.random() > 0.7 ? 'high' : Math.random() > 0.4 ? 'medium' : 'low' },
    { name: 'Position Size', status: Math.random() > 0.7 ? 'high' : Math.random() > 0.4 ? 'medium' : 'low' },
    { name: 'Correlation', status: Math.random() > 0.7 ? 'high' : Math.random() > 0.4 ? 'medium' : 'low' },
    { name: 'Daily Limits', status: Math.random() > 0.7 ? 'high' : Math.random() > 0.4 ? 'medium' : 'low' }
  ];
  
  const rejectionReasons = approved ? [] : [
    'Position size exceeds daily limit',
    'High correlation with existing positions',
    'Market volatility too high'
  ].slice(0, Math.floor(Math.random() * 2) + 1);
  
  return {
    risk_score: riskScore,
    approved: approved,
    rejection_reasons: rejectionReasons,
    risk_factors: riskFactors
  };
}

// Generate sample support resistance data
function generateSampleSupportResistance(currentPrice) {
  const support = (currentPrice * (1 - (Math.random() * 0.02 + 0.005))).toFixed(4);
  const resistance = (currentPrice * (1 + (Math.random() * 0.02 + 0.005))).toFixed(4);
  
  return {
    support: support,
    resistance: resistance
  };
}

/* ===== PERBAIKAN UTAMA: Fungsi analyze yang lebih robust ===== */
async function analyze(){
  const pair = pairSelect.value, tf = timeframeSelect.value;
  
  try {
    console.log(`Starting analysis for ${pair}-${tf}...`);
    
    // PERBAIKAN: Pastikan charts sudah di-initialize
    if (!chart || !candle) {
      console.log('Initializing charts...');
      if (!initializeCharts()) {
        throw new Error('Failed to initialize charts');
      }
    }
    
    // Ambil analysis data
    let analysisData = {};
    try {
      const response = await fetch(`/api/analyze?pair=${pair}&timeframe=${getTimeframeFilename(tf)}`);
      if (response.ok) {
        analysisData = await response.json();
        console.log('Analysis response received:', analysisData);
      } else {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch (error) {
      console.warn('Could not fetch analysis data, using sample data:', error.message);
      analysisData = generateSampleAnalysisData(pair, tf);
    }
    
    // Gunakan price_series dari analysisData jika tersedia
    let chartData = [];
    if (analysisData.price_series && analysisData.price_series.length > 0) {
      console.log(`Using ${analysisData.price_series.length} price series points from analysis`);
      chartData = analysisData.price_series;
    } else {
      // Fallback ke historical data
      console.log('No price_series in analysis, fetching historical data...');
      chartData = await fetchPriceData(pair, tf);
    }
    
    // Process chart data dengan validasi yang ketat
    const cleanData = cleanChartData(chartData);
    currentChartData = cleanData;
    
    console.log(`Setting ${cleanData.length} clean data points to chart`);
    
    if (cleanData.length > 0) {
      // PERBAIKAN: Gunakan safe function untuk set data ke chart
      const chartSuccess = safeSetChartData(candle, cleanData);
      
      if (chartSuccess) {
        const closes = cleanData.map(d => d.close);
        
        // Calculate and update EMA
        const ema = calcEMA(closes, 26);
        currentEmaData = ema.map((v, i) => ({
          time: cleanData[i].time, 
          value: isNaN(v) ? closes[i] : v
        }));
        
        safeSetChartData(ema26, currentEmaData);
        
        // Calculate and update MACD
        const {macd, sig, hist} = calcMACDSeries(closes);
        currentMacdData = { 
          macd: macd.map(v => isNaN(v) ? 0 : v),
          signal: sig.map(v => isNaN(v) ? 0 : v),
          hist: hist.map(v => isNaN(v) ? 0 : v)
        };
        
        const macdSeriesData = macd.map((v, i) => ({
          time: cleanData[i].time, 
          value: isNaN(v) ? 0 : v
        }));
        const signalSeriesData = sig.map((v, i) => ({
          time: cleanData[i].time, 
          value: isNaN(v) ? 0 : v
        }));
        const histSeriesData = hist.map((v, i) => ({
          time: cleanData[i].time, 
          value: isNaN(v) ? 0 : v
        }));
        
        safeSetChartData(macdLine, macdSeriesData);
        safeSetChartData(macdSignal, signalSeriesData);
        safeSetChartData(macdHist, histSeriesData);
        
        lastCandleTime = cleanData[cleanData.length - 1]?.time;
        
        // Update chart subtitle
        document.getElementById('chartSubtitle').textContent = 
          `${tf} Timeframe · ${cleanData.length} candles · EMA26 · MACD`;
        
        // Resize charts
        setTimeout(() => {
          try {
            chart.resize(document.getElementById('chartRoot').clientWidth, 520);
            macdChart.resize(document.getElementById('macdRoot').clientWidth, 160);
          } catch (e) {
            console.log('Chart resize error:', e);
          }
        }, 100);
      } else {
        console.warn('Failed to set chart data, using fallback data');
        await loadFallbackData();
        return;
      }
    } else {
      console.warn('No clean data available, using fallback');
      await loadFallbackData();
      return;
    }
    
    // Update technical values
    const t = analysisData.technical_analysis || {};
    console.log('Technical analysis data:', t);
    
    // Handle data technical analysis
    if (t.momentum) {
      rsiEl.textContent = (t.momentum.rsi || 0).toFixed(2);
      macdValEl.textContent = (t.momentum.macd || 0).toFixed(4);
      macdHistVal.textContent = (t.momentum.macd_histogram || 0).toFixed(4);
    } else {
      rsiEl.textContent = '50.00';
      macdValEl.textContent = '0.0000';
      macdHistVal.textContent = '0.0000';
    }
    
    if (t.trend) {
      adxEl.textContent = (t.trend.adx || 0).toFixed(2);
      trendEl.textContent = t.trend.trend_direction || 'Neutral';
    } else {
      adxEl.textContent = '25.00';
      trendEl.textContent = 'Neutral';
    }
    
    if (t.volatility) {
      atrEl.textContent = (t.volatility.atr || 0).toFixed(4);
      volEl.textContent = t.volatility.volatility_pct ? 
        (t.volatility.volatility_pct * 100).toFixed(2) + '%' : '1.00%';
    } else {
      atrEl.textContent = '0.5000';
      volEl.textContent = '1.00%';
    }
    
    // Update price data
    const priceDataInfo = analysisData.price_data || {};
    const currentPrice = priceDataInfo.current || (cleanData.length > 0 ? cleanData[cleanData.length - 1].close : 148.75);
    
    livePriceEl.textContent = currentPrice ? currentPrice.toFixed(4) : '148.7500';
    currentPriceEl.textContent = currentPrice ? currentPrice.toFixed(4) : '148.7500';
    
    // Update pair ticker dengan change
    const change = priceDataInfo.change_pct || 0;
    changeEl.textContent = '(' + (change >= 0 ? '+' : '') + change.toFixed(2) + '%)';
    changeEl.className = change >= 0 ? 'price-change change-positive' : 'price-change change-negative';
    
    // Update AI analysis
    const ai = analysisData.ai_analysis || {};
    console.log('AI analysis data:', ai);
    
    aiSummaryEl.textContent = ai.analysis_summary || `AI analysis for ${pair} on ${tf} timeframe`;
    setSignal(ai.signal || 'HOLD');
    aiConfidence.textContent = ai.confidence ? ai.confidence + '%' : '75%';
    aiRisk.textContent = ai.risk_level || 'Medium';
    aiEntry.textContent = ai.entry_price || currentPrice.toFixed(4);
    aiSL.textContent = ai.stop_loss || (currentPrice * 0.99).toFixed(4);
    aiTP1.textContent = ai.take_profit_1 || (currentPrice * 1.01).toFixed(4);
    aiTP2.textContent = ai.take_profit_2 || (currentPrice * 1.02).toFixed(4);
    
    // Update fundamental news
    fundNews.textContent = analysisData.fundamental_analysis || `Trading ${pair} on ${tf} timeframe. Market conditions appear normal.`;
    
    // Update risk assessment
    const risk = analysisData.risk_assessment || generateSampleRiskAssessment();
    updateRiskAssessment(risk);
    
    // Update Support & Resistance
    const srData = {
      support_resistance: analysisData.support_resistance || generateSampleSupportResistance(currentPrice),
      price_data: analysisData.price_data || { current: currentPrice },
      price_series: analysisData.price_series || []
    };
    updateSupportResistance(srData);
    
    updateStatusIndicator(true);
    console.log('Analysis completed successfully');
    
  } catch (error) {
    console.error('Analysis error:', error);
    updateStatusIndicator(false);
    
    // Show error to user
    aiSummaryEl.textContent = `Error: ${error.message}`;
    aiSummaryEl.style.color = '#ef4444';
    
    // Fallback ke data sample
    await loadFallbackData();
  }
}

// Fungsi fallback jika semua gagal
async function loadFallbackData() {
  console.log('Loading fallback data...');
  const pair = pairSelect.value;
  const tf = timeframeSelect.value;
  
  const sampleData = generateSampleAnalysisData(pair, tf);
  const chartData = generateSamplePriceData(tf);
  
  // Set chart data dengan safe function
  const cleanData = cleanChartData(chartData);
  safeSetChartData(candle, cleanData);
  
  // Update basic UI
  livePriceEl.textContent = '148.7500';
  currentPriceEl.textContent = '148.7500';
  setSignal('HOLD');
  aiConfidence.textContent = '75%';
  
  updateStatusIndicator(false);
}

// Fungsi bantuan untuk menghasilkan data analisis sample
function generateSampleAnalysisData(pair, timeframe) {
  const currentPrice = 148.75 + (Math.random() - 0.5) * 2;
  
  return {
    technical_analysis: {
      momentum: {
        rsi: 30 + Math.random() * 40,
        macd: (Math.random() - 0.5) * 0.1,
        macd_histogram: (Math.random() - 0.5) * 0.05
      },
      trend: {
        adx: 20 + Math.random() * 30,
        trend_direction: Math.random() > 0.5 ? 'Bullish' : 'Bearish'
      },
      volatility: {
        atr: 0.5 + Math.random() * 0.5,
        volatility_pct: 0.5 + Math.random() * 1.0
      }
    },
    price_data: {
      current: currentPrice,
      change_pct: (Math.random() - 0.5) * 2
    },
    ai_analysis: {
      analysis_summary: `AI analysis for ${pair} on ${timeframe} timeframe shows potential trading opportunities`,
      signal: Math.random() > 0.6 ? 'BUY' : Math.random() > 0.3 ? 'SELL' : 'HOLD',
      confidence: Math.floor(60 + Math.random() * 35),
      risk_level: Math.random() > 0.7 ? 'High' : Math.random() > 0.4 ? 'Medium' : 'Low',
      entry_price: (currentPrice * (1 + (Math.random() - 0.5) * 0.01)).toFixed(4),
      stop_loss: (currentPrice * (1 - Math.random() * 0.02)).toFixed(4),
      take_profit_1: (currentPrice * (1 + Math.random() * 0.02)).toFixed(4),
      take_profit_2: (currentPrice * (1 + Math.random() * 0.035)).toFixed(4)
    },
    fundamental_analysis: `Trading ${pair} on ${timeframe} timeframe. Market conditions appear normal.`,
    price_series: generateSamplePriceData(timeframe)
  };
}

/* ===== Live Price Update ===== */
let prevPrice = null;
async function updateLivePrice() {
  const pair = pairSelect.value;
  const tf = timeframeSelect.value;
  
  try {
    const priceData = await fetchPriceData(pair, tf);
    
    if (priceData && priceData.length > 0 && currentChartData.length > 0) {
      const lastPricePoint = priceData[priceData.length - 1];
      const currentPrice = lastPricePoint.close || lastPricePoint.Close;
      
      if (currentPrice) {
        livePriceEl.textContent = currentPrice.toFixed(4);
        currentPriceEl.textContent = currentPrice.toFixed(4);
        
        // Update current candle with live price
        const lastIndex = currentChartData.length - 1;
        const lastCandle = currentChartData[lastIndex];
        
        if (lastCandle) {
          const updatedCandle = {
            time: lastCandle.time,
            open: lastCandle.open,
            high: Math.max(lastCandle.high, currentPrice),
            low: Math.min(lastCandle.low, currentPrice),
            close: currentPrice
          };
          
          // Update our stored data
          currentChartData[lastIndex] = updatedCandle;
          
          // Update the chart dengan safe function
          safeUpdateChartData(candle, updatedCandle);
          
          // Update EMA dengan new close price
          const closes = currentChartData.map(d => d.close);
          const ema = calcEMA(closes, 26);
          const lastEma = ema[ema.length - 1];
          
          if (lastEma && !isNaN(lastEma)) {
            const updatedEma = {
              time: lastCandle.time,
              value: lastEma
            };
            currentEmaData[lastIndex] = updatedEma;
            safeUpdateChartData(ema26, updatedEma);
          }
          
          // Update MACD dengan new close price
          const {macd, sig, hist} = calcMACDSeries(closes);
          const lastMacd = macd[macd.length - 1];
          const lastSig = sig[sig.length - 1];
          const lastHist = hist[hist.length - 1];
          
          if (lastMacd !== undefined && !isNaN(lastMacd)) {
            currentMacdData.macd[lastIndex] = lastMacd;
            currentMacdData.signal[lastIndex] = lastSig;
            currentMacdData.hist[lastIndex] = lastHist;
            
            safeUpdateChartData(macdLine, {time: lastCandle.time, value: lastMacd});
            safeUpdateChartData(macdSignal, {time: lastCandle.time, value: lastSig});
            safeUpdateChartData(macdHist, {time: lastCandle.time, value: lastHist});
            
            macdValEl.textContent = lastMacd.toFixed(4);
            macdHistVal.textContent = lastHist.toFixed(4);
          }
        }
        
        updateStatusIndicator(true);
      }
    }
  } catch (error) {
    console.error('Live price error:', error);
    updateStatusIndicator(false);
  }
}

/* ===== Backtest Functions ===== */
function showBacktestModal() {
  const modal = new bootstrap.Modal(document.getElementById('backtestModal'));
  modal.show();
}

async function runBacktest() {
  const pair = pairSelect.value;
  const timeframe = timeframeSelect.value;
  const initialBalance = document.getElementById('initialBalance').value;
  const days = document.getElementById('backtestDays').value;
  const backtestType = document.getElementById('backtestType').value;
  
  backtestStatusEl.textContent = 'Running...';
  backtestStatusEl.className = 'badge bg-warning';
  backtestResultsEl.innerHTML = '<div class="text-center"><div class="spinner-border spinner-border-sm" role="status"></div> Running backtest...</div>';
  
  try {
    const endpoint = backtestType === 'advanced' ? '/api/advanced_backtest' : '/api/backtest';
    
    console.log('Starting backtest with:', { pair, timeframe, days, initialBalance, backtestType });
    
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        pair: pair,
        timeframe: getTimeframeFilename(timeframe),
        days: parseInt(days),
        initial_balance: parseFloat(initialBalance)
      })
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const result = await response.json();
    console.log('Backtest result:', result);
    
    if (result.status === 'success' || result.status === 'no_trades') {
      displayBacktestResults(result);
      backtestStatusEl.textContent = 'Completed';
      backtestStatusEl.className = 'badge bg-success';
    } else {
      throw new Error(result.error || 'Backtest failed');
    }
    
  } catch (error) {
    console.error('Backtest error:', error);
    backtestResultsEl.innerHTML = `<div class="alert alert-danger">Backtest failed: ${error.message}</div>`;
    backtestStatusEl.textContent = 'Failed';
    backtestStatusEl.className = 'badge bg-danger';
  }
}

function displayBacktestResults(result) {
  const summary = result.summary || {};
  const tradeAnalysis = result.trade_analysis || {};
  
  let html = '';
  
  if (result.status === 'no_trades') {
    html = `<div class="alert alert-warning">No trades were executed during the backtest period.</div>`;
    backtestResultsEl.innerHTML = html;
    return;
  }
  
  // Performance Grade
  const grade = result.performance_grade || 'N/A';
  const gradeClass = grade.startsWith('A') ? 'grade-a' : 
                    grade.startsWith('B') ? 'grade-b' :
                    grade.startsWith('C') ? 'grade-c' : 'grade-d';
  
  html += `<div class="performance-grade ${gradeClass}">Performance: ${grade}</div>`;
  
  // Summary Metrics
  html += `
    <div class="row">
      <div class="col-6">
        <div class="metric-card">
          <div class="small-muted">Total Trades</div>
          <div class="metric-value">${summary.total_trades || 0}</div>
        </div>
      </div>
      <div class="col-6">
        <div class="metric-card">
          <div class="small-muted">Win Rate</div>
          <div class="metric-value ${(summary.win_rate || 0) >= 50 ? 'change-positive' : 'change-negative'}">
            ${(summary.win_rate || 0).toFixed(1)}%
          </div>
        </div>
      </div>
    </div>
    
    <div class="row">
      <div class="col-6">
        <div class="metric-card">
          <div class="small-muted">Total Profit</div>
          <div class="metric-value ${(summary.total_profit || 0) >= 0 ? 'change-positive' : 'change-negative'}">
            $${(summary.total_profit || 0).toFixed(2)}
          </div>
        </div>
      </div>
      <div class="col-6">
        <div class="metric-card">
          <div class="small-muted">Final Balance</div>
          <div class="metric-value">$${(summary.final_balance || 0).toFixed(2)}</div>
        </div>
      </div>
    </div>
    
    <div class="row">
      <div class="col-6">
        <div class="metric-card">
          <div class="small-muted">Return %</div>
          <div class="metric-value ${(summary.return_percentage || 0) >= 0 ? 'change-positive' : 'change-negative'}">
            ${(summary.return_percentage || 0).toFixed(2)}%
          </div>
        </div>
      </div>
      <div class="col-6">
        <div class="metric-card">
          <div class="small-muted">Max Drawdown</div>
          <div class="metric-value change-negative">${(summary.max_drawdown || 0).toFixed(2)}%</div>
        </div>
      </div>
    </div>
  `;
  
  // Trade Analysis
  if (tradeAnalysis.long_trades || tradeAnalysis.short_trades) {
    html += `
      <div class="mt-3">
        <div class="small-muted mb-1">Trade Analysis</div>
        <div class="small-muted">Long Trades: ${tradeAnalysis.long_trades || 0} (Win Rate: ${(tradeAnalysis.long_win_rate || 0).toFixed(1)}%)</div>
        <div class="small-muted">Short Trades: ${tradeAnalysis.short_trades || 0} (Win Rate: ${(tradeAnalysis.short_win_rate || 0).toFixed(1)}%)</div>
      </div>
    `;
  }
  
  backtestResultsEl.innerHTML = html;
}

/* ===== Event Listeners ===== */
document.getElementById('analyzeBtn').addEventListener('click', analyze);
document.getElementById('runBacktestBtn').addEventListener('click', showBacktestModal);
document.getElementById('startBacktestBtn').addEventListener('click', runBacktest);

pairSelect.addEventListener('change', analyze);
timeframeSelect.addEventListener('change', analyze);

// Initialize dashboard dengan error handling
setTimeout(() => {
  // Initialize charts terlebih dahulu
  if (initializeCharts()) {
    analyze().catch(error => {
      console.error('Initial analysis failed:', error);
      loadFallbackData();
    });
  } else {
    console.error('Failed to initialize charts');
    loadFallbackData();
  }
}, 1000);

// Start live price updates
setInterval(updateLivePrice, 5000);

// Handle window resize
window.addEventListener('resize', () => {
  try {
    if (chart) chart.resize(document.getElementById('chartRoot').clientWidth, 520);
    if (macdChart) macdChart.resize(document.getElementById('macdRoot').clientWidth, 160);
  } catch (e) {
    console.log('Resize error:', e);
  }
});
</script>
