<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ANDRO-FX Precision Forex Trading</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.0.0/dist/lightweight-charts.standalone.production.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

  <style>
    /* CSS styles remain the same as in your original file */
    /* ... all your existing CSS ... */
  </style>
</head>
<body>

<!-- HTML structure remains the same -->
<!-- ... all your existing HTML ... -->

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script>
// Global state untuk menyimpan data chart
let currentChartData = [];
let currentEmaData = [];
let currentMacdData = { macd: [], signal: [], hist: [] };
let lastCandleTime = null;
let realtimeCandle = null;
let isRealtimeMode = false;

/* ===== Utilities ===== */
function calcEMA(values, period){
  if (!values || values.length === 0) return [];
  const k=2/(period+1);
  let ema=[values[0]];
  for(let i=1;i<values.length;i++) {
    ema.push(values[i]*k+ema[i-1]*(1-k));
  }
  return ema;
}

function calcMACDSeries(c,short=12,long=26,signal=9){
  if (!c || c.length === 0) return {macd: [], sig: [], hist: []};
  const emaS=calcEMA(c,short),emaL=calcEMA(c,long);
  const macd=c.map((_,i)=>emaS[i]-emaL[i]);
  const sig=calcEMA(macd,signal);
  const hist=macd.map((v,i)=>v-(sig[i]||0));
  return {macd,sig,hist};
}

// Calculate Pivot Points
function calculatePivotPoints(high, low, close) {
  const pivot = (high + low + close) / 3;
  const r1 = (2 * pivot) - low;
  const s1 = (2 * pivot) - high;
  const r2 = pivot + (high - low);
  const s2 = pivot - (high - low);
  const r3 = high + 2 * (pivot - low);
  const s3 = low - 2 * (high - pivot);
  
  return {
    pivot: pivot,
    r1: r1,
    r2: r2,
    r3: r3,
    s1: s1,
    s2: s2,
    s3: s3
  };
}

// Improved date formatting function untuk semua timeframe
function fmt(d, timeframe = '1D') {
  try {
    if (typeof d === 'string') {
      // Jika sudah string, parse ke Date dulu
      d = new Date(d);
    }
    
    if (d instanceof Date) {
      // Untuk semua timeframe, gunakan timestamp (lebih konsisten)
      return d.getTime() / 1000; // Convert to seconds (Lightweight Charts format)
    }
    
    // Jika sudah number (timestamp), return as-is
    return d;
  } catch (e) {
    console.error('Date formatting error:', e, d);
    return Math.floor(Date.now() / 1000);
  }
}

// Clean data - remove null/undefined values
function cleanChartData(data) {
  return data.filter(item => 
    item && 
    item.time && 
    item.open !== null && item.open !== undefined &&
    item.high !== null && item.high !== undefined &&
    item.low !== null && item.low !== undefined &&
    item.close !== null && item.close !== undefined
  ).map(item => ({
    time: item.time,
    open: parseFloat(item.open) || 0,
    high: parseFloat(item.high) || 0,
    low: parseFloat(item.low) || 0,
    close: parseFloat(item.close) || 0
  }));
}

// Generate next candle time based on timeframe
function getNextCandleTime(lastCandleTime, timeframe) {
  const lastTime = new Date(lastCandleTime * 1000);
  let nextTime;
  
  switch(timeframe) {
    case '1D':
      nextTime = new Date(lastTime);
      nextTime.setDate(nextTime.getDate() + 1);
      break;
    case '4H':
      nextTime = new Date(lastTime);
      nextTime.setHours(nextTime.getHours() + 4);
      break;
    case '1H':
      nextTime = new Date(lastTime);
      nextTime.setHours(nextTime.getHours() + 1);
      break;
    case 'M30':
      nextTime = new Date(lastTime);
      nextTime.setMinutes(nextTime.getMinutes() + 30);
      break;
    default:
      nextTime = new Date(lastTime);
      nextTime.setDate(nextTime.getDate() + 1);
  }
  
  return Math.floor(nextTime.getTime() / 1000);
}

// Create realtime candle for current period
function createRealtimeCandle(lastCandle, timeframe) {
  const currentTime = getNextCandleTime(lastCandle.time, timeframe);
  const openPrice = lastCandle.close;
  
  return {
    time: currentTime,
    open: openPrice,
    high: openPrice,
    low: openPrice,
    close: openPrice,
    isRealtime: true
  };
}

/* ===== Pair Ticker Update Function ===== */
function updatePairTicker(pair) {
  document.getElementById('selectedPair').textContent = pair + ' â€“';
}

/* ===== Risk Management Functions ===== */
function updateRiskAssessment(riskData) {
  const riskScore = riskData.risk_score || 0;
  const approved = riskData.approved;
  const rejectionReasons = riskData.rejection_reasons || [];
  const riskFactors = riskData.risk_factors || [];
  
  // Update risk score badge
  const riskScoreBadge = document.getElementById('riskScoreBadge');
  riskScoreBadge.textContent = `Score: ${riskScore}/10`;
  riskScoreBadge.className = `badge ${
    riskScore <= 3 ? 'bg-success' : 
    riskScore <= 6 ? 'bg-warning' : 'bg-danger'
  }`;
  
  // Update risk status display
  const riskMainStatus = document.getElementById('riskMainStatus');
  const riskSubStatus = document.getElementById('riskSubStatus');
  const riskStatus = document.getElementById('riskStatus');
  const riskIcon = riskStatus.querySelector('.risk-icon i');
  
  if (approved) {
    riskMainStatus.textContent = 'APPROVED';
    riskSubStatus.textContent = 'Trade meets risk criteria';
    riskStatus.style.background = 'linear-gradient(135deg, #f0f9ff, #e0f2fe)';
    riskStatus.style.border = '2px solid #bae6fd';
    riskIcon.className = 'fas fa-check-circle fa-2x text-success';
  } else {
    riskMainStatus.textContent = 'REJECTED';
    riskSubStatus.textContent = rejectionReasons.length > 0 ? 
      rejectionReasons[0] : 'Trade does not meet risk criteria';
    riskStatus.style.background = 'linear-gradient(135deg, #fef2f2, #fee2e2)';
    riskStatus.style.border = '2px solid #fecaca';
    riskIcon.className = 'fas fa-times-circle fa-2x text-danger';
  }
  
  // Update risk meter
  const riskMeterFill = document.getElementById('riskMeterFill');
  riskMeterFill.style.width = `${riskScore * 10}%`;
  riskMeterFill.style.background = riskScore <= 3 ? '#10b981' : 
                                  riskScore <= 6 ? '#f59e0b' : '#ef4444';
  
  // Update risk factors
  const riskFactorsContainer = document.getElementById('riskFactors');
  riskFactorsContainer.innerHTML = '';
  
  if (riskFactors.length > 0) {
    riskFactors.forEach(factor => {
      const factorElement = document.createElement('div');
      factorElement.className = 'col-6';
      
      let statusClass = 'pending';
      let statusIcon = 'clock';
      
      if (factor.status === 'low') {
        statusClass = 'low';
        statusIcon = 'check-circle';
      } else if (factor.status === 'medium') {
        statusClass = 'medium';
        statusIcon = 'exclamation-triangle';
      } else if (factor.status === 'high') {
        statusClass = 'high';
        statusIcon = 'times-circle';
      }
      
      factorElement.innerHTML = `
        <div class="risk-factor-card ${statusClass}">
          <i class="fas fa-${statusIcon} me-2"></i>
          <div>
            <div class="risk-factor-name">${factor.name}</div>
            <div class="risk-factor-status">${factor.status.toUpperCase()}</div>
          </div>
        </div>
      `;
      riskFactorsContainer.appendChild(factorElement);
    });
  }
  
  // Update risk details
  const riskDetails = document.getElementById('riskDetails');
  const riskWarnings = document.getElementById('riskWarnings');
  const riskRejections = document.getElementById('riskRejections');
  
  if (rejectionReasons.length > 0) {
    riskDetails.style.display = 'block';
    riskWarnings.style.display = 'none';
    riskRejections.style.display = 'block';
    riskRejections.innerHTML = `<i class="fas fa-times-circle me-2"></i><span>${rejectionReasons.join(', ')}</span>`;
  } else if (riskScore > 6) {
    riskDetails.style.display = 'block';
    riskWarnings.style.display = 'block';
    riskRejections.style.display = 'none';
    riskWarnings.innerHTML = `<i class="fas fa-exclamation-triangle me-2"></i><span>High risk score detected - proceed with caution</span>`;
  } else {
    riskDetails.style.display = 'none';
  }
}

/* ===== Support & Resistance Functions ===== */
function updateSupportResistance(data) {
  const srData = data.support_resistance || {};
  const currentPrice = data.price_data?.current || 0;
  
  // Update Support & Resistance levels
  const supportLevel = srData.support || (currentPrice * 0.995).toFixed(4);
  const resistanceLevel = srData.resistance || (currentPrice * 1.005).toFixed(4);
  
  document.getElementById('supportLevel').textContent = supportLevel;
  document.getElementById('resistanceLevel').textContent = resistanceLevel;
  
  // Calculate and display distances
  if (currentPrice > 0) {
    const supportDistance = ((currentPrice - supportLevel) / currentPrice * 100).toFixed(2);
    const resistanceDistance = ((resistanceLevel - currentPrice) / currentPrice * 100).toFixed(2);
    
    document.getElementById('supportDistance').textContent = `${supportDistance}% below`;
    document.getElementById('resistanceDistance').textContent = `${resistanceDistance}% above`;
  }
  
  // Calculate and update Pivot Points
  const priceSeries = data.price_series || [];
  if (priceSeries.length > 0) {
    const lastDay = priceSeries[priceSeries.length - 1];
    const pivots = calculatePivotPoints(
      parseFloat(lastDay.high) || currentPrice * 1.01,
      parseFloat(lastDay.low) || currentPrice * 0.99,
      parseFloat(lastDay.close) || currentPrice
    );
    
    document.getElementById('pivotPoint').textContent = pivots.pivot.toFixed(4);
    document.getElementById('pivotR1').textContent = pivots.r1.toFixed(4);
    document.getElementById('pivotR2').textContent = pivots.r2.toFixed(4);
    document.getElementById('pivotR3').textContent = pivots.r3.toFixed(4);
    document.getElementById('pivotS1').textContent = pivots.s1.toFixed(4);
    document.getElementById('pivotS2').textContent = pivots.s2.toFixed(4);
    document.getElementById('pivotS3').textContent = pivots.s3.toFixed(4);
  }
}

/* ===== Chart Setup ===== */
const chartOptions = {
  layout: { 
    backgroundColor: '#fff', 
    textColor: '#111' 
  },
  grid: {
    vertLines: { color: '#f3f4f6' },
    horzLines: { color: '#f3f4f6' }
  },
  timeScale: {
    borderColor: '#eee',
    timeVisible: true,
    secondsVisible: false,
    barSpacing: 8,
    minBarSpacing: 2,
    fixLeftEdge: true,
    fixRightEdge: true
  },
  rightPriceScale: {
    borderColor: '#eee',
    scaleMargins: {
      top: 0.1,
      bottom: 0.1
    }
  },
  width: document.getElementById('chartRoot').clientWidth,
  height: 520
};

const chart = LightweightCharts.createChart(document.getElementById('chartRoot'), chartOptions);

const candle = chart.addCandlestickSeries({
  upColor: '#16a34a',
  downColor: '#dc2626', 
  borderVisible: true,
  wickUpColor: '#16a34a',
  wickDownColor: '#dc2626',
  priceScaleId: 'right'
});

const ema26 = chart.addLineSeries({
  color: '#2563eb',
  lineWidth: 1.5,
  priceScaleId: 'right'
});

const macdChartOptions = {
  layout: { 
    backgroundColor: '#fff', 
    textColor: '#111' 
  },
  grid: {
    vertLines: { color: '#f3f4f6' },
    horzLines: { color: '#f3f4f6' }
  },
  timeScale: {
    borderColor: '#eee',
    timeVisible: true,
    secondsVisible: false,
    barSpacing: 8,
    minBarSpacing: 2
  },
  width: document.getElementById('macdRoot').clientWidth,
  height: 160
};

const macdChart = LightweightCharts.createChart(document.getElementById('macdRoot'), macdChartOptions);

const macdLine = macdChart.addLineSeries({
  color: '#0ea5e9',
  lineWidth: 1
});

const macdSignal = macdChart.addLineSeries({
  color: '#f59e0b', 
  lineWidth: 1
});

const macdHist = macdChart.addHistogramSeries({
  color: '#a78bfa',
  priceFormat: {
    type: 'volume',
  }
});

// Sync time scales between charts
chart.timeScale().subscribeVisibleTimeRangeChange((timeRange) => {
  try {
    macdChart.timeScale().setVisibleRange(timeRange);
  } catch (e) {
    console.log('Time scale sync error:', e);
  }
});

/* ===== DOM refs ===== */
const livePriceEl = document.getElementById('livePrice');
const pairSelect = document.getElementById('pairSelect');
const timeframeSelect = document.getElementById('timeframeSelect');
const aiSummaryEl = document.getElementById('aiSummary');
const aiSignal = document.getElementById('aiSignalBadge');
const aiConfidence = document.getElementById('aiConfidence');
const aiRisk = document.getElementById('aiRisk');
const aiEntry = document.getElementById('aiEntry');
const aiSL = document.getElementById('aiSL');
const aiTP1 = document.getElementById('aiTP1');
const aiTP2 = document.getElementById('aiTP2');
const fundNews = document.getElementById('fundamentalNews');
const rsiEl = document.getElementById('rsiVal');
const macdValEl = document.getElementById('macdVal');
const macdHistVal = document.getElementById('macdHistVal');
const adxEl = document.getElementById('adxVal');
const atrEl = document.getElementById('atrVal');
const volEl = document.getElementById('volVal');
const trendEl = document.getElementById('trendVal');
const changeEl = document.getElementById('pairChange');
const statusIndicator = document.getElementById('statusIndicator');
const backtestResultsEl = document.getElementById('backtestResults');
const backtestStatusEl = document.getElementById('backtestStatus');
const currentPriceEl = document.getElementById('currentPrice');
const chartLoading = document.getElementById('chartLoading');
const realtimeIndicator = document.getElementById('realtimeIndicator');

/* ===== Data state ===== */
let auto = false, autoRefreshInterval = null, livePriceInterval = null;
let currentSignal = 'HOLD';

function setSignal(sig){
  aiSignal.textContent = sig;
  currentSignal = sig;
  aiSignal.className = sig === 'BUY' ? 'ai-signal-buy' : 
                     sig === 'SELL' ? 'ai-signal-sell' : 'ai-signal-hold';
}

// Update status indicator
function updateStatusIndicator(isLive) {
  if (isLive) {
    statusIndicator.className = 'status-indicator status-live';
    statusIndicator.title = 'Live data connection active';
    realtimeIndicator.style.display = 'block';
  } else {
    statusIndicator.className = 'status-indicator status-offline';
    statusIndicator.title = 'No live data connection';
    realtimeIndicator.style.display = 'none';
  }
}

// Generate realistic sample price data untuk semua timeframe
function generateSamplePriceData(timeframe = '1D') {
  const data = [];
  const basePrice = 148.75;
  const volatility = 0.002;
  
  let periods;
  let timeIncrement;
  let baseDate = new Date('2023-01-01');
  
  // Set parameters berdasarkan timeframe
  switch(timeframe) {
    case '4H':
      periods = 90;
      timeIncrement = 4 * 60 * 60 * 1000;
      break;
    case '1H':
      periods = 168;
      timeIncrement = 60 * 60 * 1000;
      break;
    case 'M30':
      periods = 336;
      timeIncrement = 30 * 60 * 1000;
      break;
    case '1D':
    default:
      periods = 100;
      timeIncrement = 24 * 60 * 60 * 1000;
      baseDate = new Date('2023-06-01');
  }
  
  let currentPrice = basePrice;
  
  for (let i = 0; i < periods; i++) {
    const date = new Date(baseDate.getTime() + (i * timeIncrement));
    
    if (timeframe !== '1D') {
      const hour = Math.floor(Math.random() * 24);
      const minute = timeframe === 'M30' ? (Math.random() > 0.5 ? 30 : 0) : 0;
      date.setHours(hour, minute, 0, 0);
    }
    
    const change = (Math.random() - 0.5) * 2 * volatility * currentPrice;
    const open = currentPrice;
    const close = open + change;
    const high = Math.max(open, close) + Math.random() * volatility * currentPrice;
    const low = Math.min(open, close) - Math.random() * volatility * currentPrice;
    
    currentPrice = close;
    
    data.push({
      time: fmt(date, timeframe),
      open: parseFloat(open.toFixed(4)),
      high: parseFloat(high.toFixed(4)),
      low: parseFloat(low.toFixed(4)),
      close: parseFloat(close.toFixed(4))
    });
  }
  
  return data;
}

// Generate sample risk assessment data
function generateSampleRiskAssessment() {
  const riskScore = Math.floor(Math.random() * 11);
  const approved = riskScore <= 7;
  
  const riskFactors = [
    { name: 'Market Volatility', status: Math.random() > 0.7 ? 'high' : Math.random() > 0.4 ? 'medium' : 'low' },
    { name: 'Position Size', status: Math.random() > 0.7 ? 'high' : Math.random() > 0.4 ? 'medium' : 'low' },
    { name: 'Correlation', status: Math.random() > 0.7 ? 'high' : Math.random() > 0.4 ? 'medium' : 'low' },
    { name: 'Daily Limits', status: Math.random() > 0.7 ? 'high' : Math.random() > 0.4 ? 'medium' : 'low' }
  ];
  
  const rejectionReasons = approved ? [] : [
    'Position size exceeds daily limit',
    'High correlation with existing positions',
    'Market volatility too high'
  ].slice(0, Math.floor(Math.random() * 2) + 1);
  
  return {
    risk_score: riskScore,
    approved: approved,
    rejection_reasons: rejectionReasons,
    risk_factors: riskFactors
  };
}

// Generate sample support resistance data
function generateSampleSupportResistance(currentPrice) {
  const support = (currentPrice * (1 - (Math.random() * 0.02 + 0.005))).toFixed(4);
  const resistance = (currentPrice * (1 + (Math.random() * 0.02 + 0.005))).toFixed(4);
  
  return {
    support: support,
    resistance: resistance
  };
}

/* ===== Fetch + Render ===== */
async function analyze(){
  const pair = pairSelect.value, tf = timeframeSelect.value;
  
  // Show loading indicator
  chartLoading.style.display = 'block';
  
  // Update pair ticker text
  updatePairTicker(pair);
  
  try {
    console.log(`Fetching analysis for ${pair}-${tf}...`);
    
    // Menggunakan POST request sesuai dengan backend
    const r = await fetch(`/api/analyze`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        pair: pair,
        timeframe: tf
      })
    }); 
    
    if (!r.ok) {
      throw new Error(`HTTP error! status: ${r.status}`);
    }
    
    const j = await r.json();
    console.log('Analysis response:', j);
    
    // Update price series chart
    let chartData = [];
    
    if (j.price_series && j.price_series.length > 0) {
      console.log(`Processing ${j.price_series.length} price series data points`);
      chartData = j.price_series.map(p => ({
        time: fmt(p.time || p.date, tf),
        open: parseFloat(p.open) || 0,
        high: parseFloat(p.high) || 0,
        low: parseFloat(p.low) || 0,
        close: parseFloat(p.close) || 0
      }));
    } else {
      console.warn('No price_series data, using sample data');
      chartData = generateSamplePriceData(tf);
    }
    
    // Clean and set chart data
    const cleanData = cleanChartData(chartData);
    
    // Add realtime candle for current period
    if (cleanData.length > 0) {
      const lastCandle = cleanData[cleanData.length - 1];
      realtimeCandle = createRealtimeCandle(lastCandle, tf);
      currentChartData = [...cleanData, realtimeCandle];
      isRealtimeMode = true;
    } else {
      currentChartData = cleanData;
      isRealtimeMode = false;
    }
    
    if (currentChartData.length > 0) {
      candle.setData(currentChartData);
      
      const closes = currentChartData.map(d => d.close);
      
      // Calculate and update EMA
      const ema = calcEMA(closes, 26);
      currentEmaData = ema.map((v, i) => ({
        time: currentChartData[i].time, 
        value: isNaN(v) ? 0 : v
      }));
      ema26.setData(currentEmaData);
      
      // Calculate and update MACD
      const {macd, sig, hist} = calcMACDSeries(closes);
      currentMacdData = { 
        macd: macd.map(v => isNaN(v) ? 0 : v),
        signal: sig.map(v => isNaN(v) ? 0 : v),
        hist: hist.map(v => isNaN(v) ? 0 : v)
      };
      
      const macdSeriesData = macd.map((v, i) => ({
        time: currentChartData[i].time, 
        value: isNaN(v) ? 0 : v
      }));
      const signalSeriesData = sig.map((v, i) => ({
        time: currentChartData[i].time, 
        value: isNaN(v) ? 0 : v
      }));
      const histSeriesData = hist.map((v, i) => ({
        time: currentChartData[i].time, 
        value: isNaN(v) ? 0 : v
      }));
      
      macdLine.setData(macdSeriesData);
      macdSignal.setData(signalSeriesData);
      macdHist.setData(histSeriesData);
      
      lastCandleTime = currentChartData[currentChartData.length - 1]?.time;
      
      // Update chart time scale settings
      try {
        const timeScaleOptions = {
          timeVisible: true,
          secondsVisible: false
        };
        
        if (tf === '1D') {
          timeScaleOptions.barSpacing = 6;
        } else if (tf === '4H') {
          timeScaleOptions.barSpacing = 4;
        } else {
          timeScaleOptions.barSpacing = 2;
        }
        
        chart.timeScale().applyOptions(timeScaleOptions);
        macdChart.timeScale().applyOptions(timeScaleOptions);
        
        // Fit content untuk menampilkan semua data
        chart.timeScale().fitContent();
        macdChart.timeScale().fitContent();
      } catch (e) {
        console.log('Time scale update error:', e);
      }
      
      // Resize charts
      setTimeout(() => {
        try {
          const chartWidth = document.getElementById('chartRoot').clientWidth;
          const macdWidth = document.getElementById('macdRoot').clientWidth;
          
          chart.resize(chartWidth, 520);
          macdChart.resize(macdWidth, 160);
        } catch (e) {
          console.log('Chart resize error:', e);
        }
      }, 300);
    }
    
    // Update technical values - sesuai dengan struktur backend
    const t = j.technical_analysis || {};
    console.log('Technical analysis:', t);
    
    // Handle momentum indicators
    if (t.momentum) {
      rsiEl.textContent = (t.momentum.rsi || 0).toFixed(2);
      macdValEl.textContent = (t.momentum.macd || 0).toFixed(4);
      macdHistVal.textContent = (t.momentum.macd_histogram || 0).toFixed(4);
    } else {
      rsiEl.textContent = '-';
      macdValEl.textContent = '-';
      macdHistVal.textContent = '-';
    }
    
    // Handle trend indicators
    if (t.trend) {
      adxEl.textContent = (t.trend.adx || 0).toFixed(2);
      trendEl.textContent = t.trend.trend_direction || '-';
    } else {
      adxEl.textContent = '-';
      trendEl.textContent = '-';
    }
    
    // Handle volatility indicators
    if (t.volatility) {
      atrEl.textContent = (t.volatility.atr || 0).toFixed(4);
      volEl.textContent = t.volatility.volatility_pct ? 
        (t.volatility.volatility_pct * 100).toFixed(2) + '%' : '-';
    } else {
      atrEl.textContent = '-';
      volEl.textContent = '-';
    }
    
    // Update price data - sesuai dengan struktur backend
    const currentPrice = j.current_price || (t.levels && t.levels.current_price);
    livePriceEl.textContent = currentPrice ? currentPrice.toFixed(4) : '-';
    currentPriceEl.textContent = currentPrice ? currentPrice.toFixed(4) : '-';
    
    // Update pair ticker with change
    const change = j.change_percentage || (t.levels && t.levels.change_percentage) || 0;
    changeEl.textContent = '(' + (change >= 0 ? '+' : '') + change.toFixed(2) + '%)';
    changeEl.className = change >= 0 ? 'price-change change-positive' : 'price-change change-negative';
    
    // Update AI analysis - sesuai dengan struktur backend
    const ai = j.ai_analysis || {};
    console.log('AI analysis:', ai);
    
    aiSummaryEl.textContent = ai.analysis_summary || 'No analysis available';
    setSignal(ai.signal || 'HOLD');
    aiConfidence.textContent = ai.confidence ? ai.confidence + '%' : '-';
    aiRisk.textContent = ai.risk_level || '-';
    aiEntry.textContent = ai.entry_price || '-';
    aiSL.textContent = ai.stop_loss || '-';
    aiTP1.textContent = ai.take_profit_1 || '-';
    aiTP2.textContent = ai.take_profit_2 || '-';
    
    // Update fundamental news
    fundNews.textContent = j.fundamental_analysis || 'No news available';
    
    // Update risk assessment dengan struktur backend
    const risk = j.risk_assessment || generateSampleRiskAssessment();
    updateRiskAssessment(risk);
    
    // Update Support & Resistance
    const srData = {
      support_resistance: j.support_resistance || generateSampleSupportResistance(currentPrice),
      price_data: { current: currentPrice },
      price_series: j.price_series || []
    };
    updateSupportResistance(srData);
    
    updateStatusIndicator(true);
    
  } catch (error) {
    console.error('Analysis error:', error);
    updateStatusIndicator(false);
    
    // Show error to user
    aiSummaryEl.textContent = `Error: ${error.message}`;
    aiSummaryEl.style.color = '#ef4444';
  } finally {
    // Hide loading indicator
    chartLoading.style.display = 'none';
  }
}

/* ===== Live Price Update ===== */
let prevPrice = null;
async function updateLivePrice() {
  const pair = pairSelect.value;
  try {
    // Use the analyze endpoint dengan POST
    const r = await fetch(`/api/analyze`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        pair: pair,
        timeframe: timeframeSelect.value
      })
    });
    
    if (!r.ok) return;
    
    const j = await r.json();
    
    const currentPrice = j.current_price;
    
    if (currentPrice && currentChartData.length > 0 && isRealtimeMode) {
      livePriceEl.textContent = currentPrice.toFixed(4);
      currentPriceEl.textContent = currentPrice.toFixed(4);
      
      // Update price change
      const change = j.change_percentage || 0;
      changeEl.textContent = '(' + (change >= 0 ? '+' : '') + change.toFixed(2) + '%)';
      changeEl.className = change >= 0 ? 'price-change change-positive' : 'price-change change-negative';
      
      // Update realtime candle with live price
      if (realtimeCandle) {
        const updatedCandle = {
          time: realtimeCandle.time,
          open: realtimeCandle.open,
          high: Math.max(realtimeCandle.high, currentPrice),
          low: Math.min(realtimeCandle.low, currentPrice),
          close: currentPrice
        };
        
        // Update our stored data
        realtimeCandle = updatedCandle;
        currentChartData[currentChartData.length - 1] = updatedCandle;
        
        // Update the chart
        candle.update(updatedCandle);
        
        // Update EMA with new close price (exclude realtime candle from calculation)
        const historicalCloses = currentChartData
          .slice(0, -1)
          .map(d => d.close)
          .concat([currentPrice]);
        
        const ema = calcEMA(historicalCloses, 26);
        const lastEma = ema[ema.length - 1];
        
        if (lastEma && !isNaN(lastEma)) {
          const updatedEma = {
            time: updatedCandle.time,
            value: lastEma
          };
          currentEmaData[currentEmaData.length - 1] = updatedEma;
          ema26.update(updatedEma);
        }
        
        // Update MACD with new close price (exclude realtime candle)
        const {macd, sig, hist} = calcMACDSeries(historicalCloses);
        const lastMacd = macd[macd.length - 1];
        const lastSig = sig[sig.length - 1];
        const lastHist = hist[hist.length - 1];
        
        if (lastMacd !== undefined && !isNaN(lastMacd)) {
          currentMacdData.macd[currentMacdData.macd.length - 1] = lastMacd;
          currentMacdData.signal[currentMacdData.signal.length - 1] = lastSig;
          currentMacdData.hist[currentMacdData.hist.length - 1] = lastHist;
          
          macdLine.update({time: updatedCandle.time, value: lastMacd});
          macdSignal.update({time: updatedCandle.time, value: lastSig});
          macdHist.update({time: updatedCandle.time, value: lastHist});
          
          macdValEl.textContent = lastMacd.toFixed(4);
          macdHistVal.textContent = lastHist.toFixed(4);
        }
      }
      
      updateStatusIndicator(true);
    }
  } catch (error) {
    console.error('Live price error:', error);
    updateStatusIndicator(false);
  }
}

/* ===== Backtest Functions ===== */
function showBacktestModal() {
  const modal = new bootstrap.Modal(document.getElementById('backtestModal'));
  modal.show();
}

async function runBacktest() {
  const pair = pairSelect.value;
  const timeframe = timeframeSelect.value;
  const initialBalance = document.getElementById('initialBalance').value;
  const days = document.getElementById('backtestDays').value;
  const backtestType = document.getElementById('backtestType').value;
  
  backtestStatusEl.textContent = 'Running...';
  backtestStatusEl.className = 'badge bg-warning';
  backtestResultsEl.innerHTML = '<div class="text-center"><div class="spinner-border spinner-border-sm" role="status"></div> Running backtest...</div>';
  
  try {
    const endpoint = backtestType === 'advanced' ? '/api/advanced_backtest' : '/api/backtest';
    
    console.log('Starting backtest with:', { pair, timeframe, days, initialBalance, backtestType });
    
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        pair: pair,
        timeframe: timeframe,
        days: parseInt(days),
        initial_balance: parseFloat(initialBalance)
      })
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const result = await response.json();
    console.log('Backtest result:', result);
    
    if (result.status === 'success' || result.status === 'no_trades') {
      displayBacktestResults(result);
      backtestStatusEl.textContent = 'Completed';
      backtestStatusEl.className = 'badge bg-success';
    } else {
      throw new Error(result.error || 'Backtest failed');
    }
    
  } catch (error) {
    console.error('Backtest error:', error);
    backtestResultsEl.innerHTML = `<div class="alert alert-danger">Backtest failed: ${error.message}</div>`;
    backtestStatusEl.textContent = 'Failed';
    backtestStatusEl.className = 'badge bg-danger';
  }
}

function displayBacktestResults(result) {
  const summary = result.summary || {};
  const tradeAnalysis = result.trade_analysis || {};
  
  let html = '';
  
  if (result.status === 'no_trades') {
    html = `<div class="alert alert-warning">No trades were executed during the backtest period.</div>`;
    backtestResultsEl.innerHTML = html;
    return;
  }
  
  // Performance Grade
  const grade = result.performance_grade || 'N/A';
  const gradeClass = grade.startsWith('A') ? 'grade-a' : 
                    grade.startsWith('B') ? 'grade-b' :
                    grade.startsWith('C') ? 'grade-c' : 'grade-d';
  
  html += `<div class="performance-grade ${gradeClass}">Performance: ${grade}</div>`;
  
  // Summary Metrics
  html += `
    <div class="row">
      <div class="col-6">
        <div class="metric-card">
          <div class="small-muted">Total Trades</div>
          <div class="metric-value">${summary.total_trades || 0}</div>
        </div>
      </div>
      <div class="col-6">
        <div class="metric-card">
          <div class="small-muted">Win Rate</div>
          <div class="metric-value ${(summary.win_rate || 0) >= 50 ? 'change-positive' : 'change-negative'}">
            ${(summary.win_rate || 0).toFixed(1)}%
          </div>
        </div>
      </div>
    </div>
    
    <div class="row">
      <div class="col-6">
        <div class="metric-card">
          <div class="small-muted">Total Profit</div>
          <div class="metric-value ${(summary.total_profit || 0) >= 0 ? 'change-positive' : 'change-negative'}">
            $${(summary.total_profit || 0).toFixed(2)}
          </div>
        </div>
      </div>
      <div class="col-6">
        <div class="metric-card">
          <div class="small-muted">Final Balance</div>
          <div class="metric-value">$${(summary.final_balance || 0).toFixed(2)}</div>
        </div>
      </div>
    </div>
    
    <div class="row">
      <div class="col-6">
        <div class="metric-card">
          <div class="small-muted">Return %</div>
          <div class="metric-value ${(summary.return_percentage || 0) >= 0 ? 'change-positive' : 'change-negative'}">
            ${(summary.return_percentage || 0).toFixed(2)}%
          </div>
        </div>
      </div>
      <div class="col-6">
        <div class="metric-card">
          <div class="small-muted">Max Drawdown</div>
          <div class="metric-value change-negative">${(summary.max_drawdown || 0).toFixed(2)}%</div>
        </div>
      </div>
    </div>
  `;
  
  // Trade Analysis
  if (tradeAnalysis.long_trades || tradeAnalysis.short_trades) {
    html += `
      <div class="mt-3">
        <div class="small-muted mb-1">Trade Analysis</div>
        <div class="small-muted">Long Trades: ${tradeAnalysis.long_trades || 0} (Win Rate: ${(tradeAnalysis.long_win_rate || 0).toFixed(1)}%)</div>
        <div class="small-muted">Short Trades: ${tradeAnalysis.short_trades || 0} (Win Rate: ${(tradeAnalysis.short_win_rate || 0).toFixed(1)}%)</div>
      </div>
    `;
  }
  
  backtestResultsEl.innerHTML = html;
}

/* ===== Event Listeners ===== */
document.getElementById('analyzeBtn').addEventListener('click', analyze);
document.getElementById('runBacktestBtn').addEventListener('click', showBacktestModal);
document.getElementById('startBacktestBtn').addEventListener('click', runBacktest);

pairSelect.addEventListener('change', function() {
  updatePairTicker(this.value);
  analyze();
});
timeframeSelect.addEventListener('change', analyze);

// Initialize dashboard
updatePairTicker(pairSelect.value);
analyze();

// Start live price updates every 3 seconds for more responsive UI
setInterval(updateLivePrice, 3000);

// Improved window resize handler
let resizeTimeout;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    try {
      const chartWidth = document.getElementById('chartRoot').clientWidth;
      const macdWidth = document.getElementById('macdRoot').clientWidth;
      
      chart.resize(chartWidth, 520);
      macdChart.resize(macdWidth, 160);
      
      // Re-apply time scale settings after resize
      chart.timeScale().fitContent();
      macdChart.timeScale().fitContent();
    } catch (e) {
      console.log('Resize error:', e);
    }
  }, 250);
});
</script>
</body>
</html>
