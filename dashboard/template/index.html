/* ===== Fetch + Render ===== */
async function analyze(){
  const pair = pairSelect.value, tf = timeframeSelect.value;
  
  // Show loading indicator
  chartLoading.style.display = 'block';
  
  // Update pair ticker text
  updatePairTicker(pair);
  
  try {
    console.log(`Fetching analysis for ${pair}-${tf}...`);
    const r = await fetch(`/api/analyze?pair=${pair}&timeframe=${tf}`); 
    
    if (!r.ok) {
      throw new Error(`HTTP error! status: ${r.status}`);
    }
    
    const j = await r.json();
    console.log('Analysis response:', j);
    
    // Update price series chart - GUNAKAN DATA DARI BACKEND
    let chartData = [];
    
    if (j.price_series && j.price_series.length > 0) {
      console.log(`Processing ${j.price_series.length} price series data points`);
      chartData = j.price_series.map(p => ({
        time: fmt(p.date, tf),
        open: parseFloat(p.open) || 0,
        high: parseFloat(p.high) || 0,
        low: parseFloat(p.low) || 0,
        close: parseFloat(p.close) || 0
      }));
    } else {
      console.warn('No price_series data, using sample data');
      chartData = generateSamplePriceData(tf);
    }
    
    // Clean and set chart data
    const cleanData = cleanChartData(chartData);
    
    // Add realtime candle untuk semua timeframe
    if (cleanData.length > 0) {
      const lastCandle = cleanData[cleanData.length - 1];
      realtimeCandle = createRealtimeCandle(lastCandle, tf);
      currentChartData = [...cleanData, realtimeCandle];
      isRealtimeMode = true;
    } else {
      currentChartData = cleanData;
      isRealtimeMode = false;
    }
    
    if (currentChartData.length > 0) {
      candle.setData(currentChartData);
      
      const closes = currentChartData.map(d => d.close);
      
      // Calculate and update EMA
      const ema = calcEMA(closes, 26);
      currentEmaData = ema.map((v, i) => ({
        time: currentChartData[i].time, 
        value: isNaN(v) ? 0 : v
      }));
      ema26.setData(currentEmaData);
      
      // Calculate and update MACD
      const {macd, sig, hist} = calcMACDSeries(closes);
      currentMacdData = { 
        macd: macd.map(v => isNaN(v) ? 0 : v),
        signal: sig.map(v => isNaN(v) ? 0 : v),
        hist: hist.map(v => isNaN(v) ? 0 : v)
      };
      
      const macdSeriesData = macd.map((v, i) => ({
        time: currentChartData[i].time, 
        value: isNaN(v) ? 0 : v
      }));
      const signalSeriesData = sig.map((v, i) => ({
        time: currentChartData[i].time, 
        value: isNaN(v) ? 0 : v
      }));
      const histSeriesData = hist.map((v, i) => ({
        time: currentChartData[i].time, 
        value: isNaN(v) ? 0 : v
      }));
      
      macdLine.setData(macdSeriesData);
      macdSignal.setData(signalSeriesData);
      macdHist.setData(histSeriesData);
      
      lastCandleTime = currentChartData[currentChartData.length - 1]?.time;
      
      // Update chart time scale settings untuk semua timeframe
      try {
        const timeScaleOptions = {
          timeVisible: true,
          secondsVisible: false
        };
        
        // Set bar spacing berdasarkan timeframe
        if (tf === '1D') {
          timeScaleOptions.barSpacing = 6;
        } else if (tf === '4H') {
          timeScaleOptions.barSpacing = 4;
        } else if (tf === '1H') {
          timeScaleOptions.barSpacing = 3;
        } else { // M30
          timeScaleOptions.barSpacing = 2;
        }
        
        chart.timeScale().applyOptions(timeScaleOptions);
        macdChart.timeScale().applyOptions(timeScaleOptions);
        
        // Fit content untuk menampilkan semua data
        chart.timeScale().fitContent();
        macdChart.timeScale().fitContent();
      } catch (e) {
        console.log('Time scale update error:', e);
      }
      
      // Resize charts
      setTimeout(() => {
        try {
          const chartWidth = document.getElementById('chartRoot').clientWidth;
          const macdWidth = document.getElementById('macdRoot').clientWidth;
          
          chart.resize(chartWidth, 520);
          macdChart.resize(macdWidth, 160);
        } catch (e) {
          console.log('Chart resize error:', e);
        }
      }, 300);
    }
    
    // Update technical values dari backend response
    const t = j.technical_analysis || {};
    console.log('Technical analysis:', t);
    
    // Handle momentum indicators
    if (t.momentum) {
      rsiEl.textContent = (t.momentum.rsi || 0).toFixed(2);
      macdValEl.textContent = (t.momentum.macd || 0).toFixed(4);
      macdHistVal.textContent = (t.momentum.macd_histogram || 0).toFixed(4);
    } else {
      rsiEl.textContent = '-';
      macdValEl.textContent = '-';
      macdHistVal.textContent = '-';
    }
    
    // Handle trend indicators
    if (t.trend) {
      adxEl.textContent = (t.trend.adx || 0).toFixed(2);
      trendEl.textContent = t.trend.trend_direction || '-';
    } else {
      adxEl.textContent = '-';
      trendEl.textContent = '-';
    }
    
    // Handle volatility indicators
    if (t.volatility) {
      atrEl.textContent = (t.volatility.atr || 0).toFixed(4);
      volEl.textContent = t.volatility.volatility_pct ? 
        (t.volatility.volatility_pct).toFixed(2) + '%' : '-';
    } else {
      atrEl.textContent = '-';
      volEl.textContent = '-';
    }
    
    // Update price data
    const currentPrice = t.levels?.current_price || 150.0;
    livePriceEl.textContent = currentPrice ? currentPrice.toFixed(4) : '-';
    currentPriceEl.textContent = currentPrice ? currentPrice.toFixed(4) : '-';
    
    // Update pair ticker dengan price change dari momentum
    const priceChange = t.momentum?.price_change_pct || 0;
    changeEl.textContent = '(' + (priceChange >= 0 ? '+' : '') + priceChange.toFixed(2) + '%)';
    changeEl.className = priceChange >= 0 ? 'price-change change-positive' : 'price-change change-negative';
    
    // Update AI analysis - GUNAKAN DATA REAL DARI BACKEND
    const ai = j.ai_analysis || {};
    console.log('AI analysis:', ai);
    
    aiSummaryEl.textContent = ai.analysis_summary || 'Market analysis in progress...';
    setSignal(ai.signal || 'HOLD');
    aiConfidence.textContent = ai.confidence ? ai.confidence + '%' : '50%';
    aiRisk.textContent = ai.risk_level || 'MEDIUM';
    
    // Calculate trading levels berdasarkan analisis AI
    if (currentPrice) {
      const stopLossPct = t.timeframe_params?.STOP_LOSS_PCT || 0.01;
      const takeProfitPct = t.timeframe_params?.TAKE_PROFIT_PCT || 0.02;
      
      if (ai.signal === 'BUY') {
        aiEntry.textContent = (currentPrice * 1.0005).toFixed(4);
        aiSL.textContent = (currentPrice * (1 - stopLossPct)).toFixed(4);
        aiTP1.textContent = (currentPrice * (1 + takeProfitPct * 0.7)).toFixed(4);
        aiTP2.textContent = (currentPrice * (1 + takeProfitPct)).toFixed(4);
      } else if (ai.signal === 'SELL') {
        aiEntry.textContent = (currentPrice * 0.9995).toFixed(4);
        aiSL.textContent = (currentPrice * (1 + stopLossPct)).toFixed(4);
        aiTP1.textContent = (currentPrice * (1 - takeProfitPct * 0.7)).toFixed(4);
        aiTP2.textContent = (currentPrice * (1 - takeProfitPct)).toFixed(4);
      } else {
        aiEntry.textContent = '-';
        aiSL.textContent = '-';
        aiTP1.textContent = '-';
        aiTP2.textContent = '-';
      }
    }
    
    // Update fundamental news - GUNAKAN DATA REAL DARI BACKEND
    fundNews.textContent = j.fundamental_analysis || 'Market analysis ongoing.';
    
    // Update risk assessment
    const risk = j.risk_assessment || generateSampleRiskAssessment();
    updateRiskAssessment(risk);
    
    // Update Support & Resistance dari technical analysis levels
    const srData = {
      levels: t.levels || {},
      current_price: currentPrice
    };
    updateSupportResistance(srData);
    
    updateStatusIndicator(true);
    
  } catch (error) {
    console.error('Analysis error:', error);
    updateStatusIndicator(false);
    
    // Show error to user
    aiSummaryEl.textContent = `Error: ${error.message}`;
    aiSummaryEl.style.color = '#ef4444';
  } finally {
    // Hide loading indicator
    chartLoading.style.display = 'none';
  }
}
